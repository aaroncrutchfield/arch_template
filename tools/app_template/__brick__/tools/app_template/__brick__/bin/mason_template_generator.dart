import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:args/args.dart';

void main(List<String> args) async {
  final parser = ArgParser()
    ..addOption(
      'output',
      abbr: 'o',
      help: 'Output directory for the Mason brick',
      mandatory: true,
    );

  try {
    final results = parser.parse(args);
    final generator = MasonTemplateGenerator(
      sourceDir: Directory.current,
      outputDir: Directory(results['output'] as String),
    );
    await generator.generate();
  } on FormatException catch (e) {
    print('Error: ${e.message}\n');
    print(
      'Usage: dart run mason_template_generator.dart -o <output_directory>',
    );
    exit(1);
  }
}

class MasonTemplateGenerator {
  MasonTemplateGenerator({
    required Directory sourceDir,
    required Directory outputDir,
  })  : _sourceDir = sourceDir,
        _outputDir = outputDir,
        _projectName = path.basename(sourceDir.path);

  final Directory _sourceDir;
  final Directory _outputDir;
  final String _projectName;
  late final String _brickName = '${_projectName}_template';

  final _ignorePatterns = [
    RegExp(r'\.git/'),
    RegExp(r'\.dart_tool/'),
    RegExp(r'\.mason/'),
    RegExp(r'build/'),
    RegExp(r'\.packages$'),
    RegExp(r'\.lock$'),
    RegExp(r'\.iml$'),
    RegExp(r'\.log$'),
  ];

  Map<String, String> get _replacements => {
        _projectName: '{{project_name}}',
        _toTitleCase(_projectName): '{{project_name.pascalCase}}',
        _projectName.toLowerCase(): '{{project_name.snakeCase}}',
      };

  Future<void> generate() async {
    print('Generating Mason brick from $_projectName...');

    final brickDir = await _createBrickStructure();
    await _copyAndProcessFiles(brickDir);
    await _createBrickYaml();

    print('Mason brick generated successfully at ${_outputDir.path}');
  }

  Future<Directory> _createBrickStructure() async {
    final brickDir = Directory(path.join(_outputDir.path, '__brick__'));
    await brickDir.create(recursive: true);
    return brickDir;
  }

  Future<void> _copyAndProcessFiles(Directory brickDir) async {
    await for (final entity in _sourceDir.list(recursive: true)) {
      if (entity is! File || _shouldIgnore(entity.path)) continue;

      final relativePath = path.relative(entity.path, from: _sourceDir.path);
      final targetFile = File(path.join(brickDir.path, relativePath));

      await targetFile.parent.create(recursive: true);

      try {
        final content = await entity.readAsString();
        final processedContent = _processContent(content);
        await targetFile.writeAsString(processedContent);
      } on FileSystemException {
        // If we can't read/write as string (binary file), copy as-is
        await entity.copy(targetFile.path);
      }
    }
  }

  Future<void> _createBrickYaml() async {
    final config = {
      'name': _brickName,
      'description':
          'A brick to create a new Flutter application based on $_projectName',
      'version': '0.1.0+1',
      'environment': {'mason': '>=0.1.0-dev <0.1.0'},
      'vars': {
        'project_name': {
          'type': 'string',
          'description': 'The project name',
          'prompt': 'What is the project name?',
        },
        'org_name': {
          'type': 'string',
          'description': 'The organization name (reverse domain notation)',
          'prompt': 'What is the organization name (com.example)?',
          'default': 'com.example',
        },
      },
    };

    final yamlFile = File(path.join(_outputDir.path, 'brick.yaml'));
    final yamlContent = StringBuffer()
      ..writeln('# Generated by mason_template_generator')
      ..writeln();

    _writeYaml(config, yamlContent);
    await yamlFile.writeAsString(yamlContent.toString());
  }

  void _writeYaml(dynamic data, StringBuffer buffer, [int indent = 0]) {
    final spaces = ' ' * indent;

    if (data is Map) {
      if (indent > 0) buffer.writeln();
      data.forEach((key, value) {
        buffer.write('$spaces$key:');
        if (value is Map || value is List) {
          _writeYaml(value, buffer, indent + 2);
        } else {
          // Add quotes for version strings and similar values containing special characters
          final needsQuotes = value.toString().contains(RegExp(r'[><=]'));
          final formattedValue = needsQuotes ? '"$value"' : value;
          buffer.writeln(' $formattedValue');
        }
      });
    } else if (data is List) {
      buffer.writeln();
      for (final item in data) {
        buffer.write('$spaces- ');
        _writeYaml(item, buffer, indent + 2);
      }
    } else {
      buffer.writeln(' $data');
    }
  }

  bool _shouldIgnore(String filePath) {
    final relativePath = path.relative(filePath, from: _sourceDir.path);
    return _ignorePatterns.any((pattern) => pattern.hasMatch(relativePath));
  }

  String _processContent(String content) {
    var processed = content;
    for (final entry in _replacements.entries) {
      processed = processed.replaceAll(entry.key, entry.value);
    }
    return processed;
  }

  String _toTitleCase(String input) {
    if (input.isEmpty) return input;
    return input[0].toUpperCase() + input.substring(1);
  }
}
